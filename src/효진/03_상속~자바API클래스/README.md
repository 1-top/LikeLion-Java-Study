## 상속
* 상속 : 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것
    * 기존에 작성된 클래스를 재활용
    * 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 됨
    * 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련
    
* 자식클래스 : 부모 클래스의 모든 특성을 물려받아 새롭게 작성된 클래스
    * 선언 : `class 자식클래스이름 extend 부모클래스이름 { ... }`
    
* Object 클래스 : 모든 클래스의 부모 클래스가 되는 클래스

* super와 super()
    * super 키워드 : 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수
        * 부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 super 키워드를 사용하여 구별
    * super() 메소드 : 부모 클래스의 생성자를 호출할 때 사용
    
* 메소드 오버라이딩(method overriding) : 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것
    * 오버라이딩 조건
        * 오버라이딩이란 메소드의 동작만을 재정의하는 것이므로, 메소드의 선언부는 기존 메소드와 완전히 같아야 함
          (메소드의 반환 타입은 부모 클래스의 반환 타입으로 타입 변환할 수 있는 타입이라면 변경할 수 있음)
        * 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경할 수 없음
        * 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없음
    * 오버로딩, 오버라이딩 : 오버로딩(overloading)은 새로운 메소드를 정의하는 것, 오버라이딩(overriding)은 상속받은 기존의 메소드를 재정의하는 것
    
## 다형성
* 다형성(polymorphism) : 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미
    * 참조변수의 다형성 : 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조
    * 참조변수의 타입변환 조건
        * 서로 상속 관계에 있는 클래스 사이에만 타입 변환
        * 자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략 가능
        * 부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시
    * instanceof 연산자 : 인스턴스의 실제 타입을 확인(`참조변수 instanceof 클래스이름`)
    
* 추상클래스
    * 추상메소드 : 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드
        * 목적 : 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함
        * 문법 : `abstract 반환타입 메소드이름();`
        
    * 추상클래스 : 하나 이상의 추상 메소드를 포함하는 클래스
        * 다형성을 가지는 메소드의 집합을 정의
        * 반드시 사용되어야 하는 메소드를 추상 클래스에 추상 메소드로 선언해 놓으면, 이 클래스를 상속받는 모든 클래스에서는 추상 메소드를 반드시 재정의해야 함
        * 문법
        ```java
        abstract class 클래스이름 {
        ...
        abstract 반환타입 메소드이름();
        ...
        }
        ```
  
* 인터페이스 : 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미
    * 문법
    ```java
    접근제어자 interface 인터페이스이름 {
    public static final 타입 상수이름 = 값;
    ...
    public abstract 메소드이름(매개변수목록);
    ...
    }
    ```
    * 인터페이스의 구현 : `class 클래스이름 implements 인터페이스이름 { ... }`
    * 인터페이스의 장점
        * 대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 표준화 가능
        * 클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, 개발 시간을 단축
        * 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 독립적인 프로그래밍이 가능
    
* 내부클래스 : 하나의 클래스 내부에 선언된 또 다른 클래스
    * 문법
    ```java
    class Outer {     // 외부 클래스
        ...
        class Inner { // 내부 클래스
            ...
        }
        ...
    }
    ```
    * 내부클래스의 장점
        * 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근
        * 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 코드의 캡슐화
        * 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 복잡성을 줄임
        * 익명 클래스(anonymous class) : 이름을 가지지 않는 클래스를 의미
    