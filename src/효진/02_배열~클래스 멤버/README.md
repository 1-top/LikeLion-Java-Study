## 배열
### 1. 메모리구조
메모리구조 : 자바 가상 머신 (JVM)을 통해 실행  
* 메소드(method) 영역 : 클래스에 대한 정보와 함께 클래스 변수가 저장되는 영역
* 힙(heap) 영역 : 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역
* 스택(stack) 영역 :  메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역

###2. 배열
배열 :  같은 타입의 변수들로 이루어진 유한 집합
* 요소(element) : 배열을 구성하는 각각의 값
* 인덱스(index) : 배열 내에서 위치를 가리키는 숫자

1. 1차원 배열
    * 문법
    ```java
    // new 키워드를 사용하여 배열 생성
    배열이름 = new 타입[배열길이];
    // 배열의 선언과 생성을 동시에 하는 경우
    타입[] 배열이름 = new 타입[배열길이];
    ```
    * 배열의 초기화
    ```java
    // 첫번째 방법
    타입[] 배열이름 = {배열요소1, 배열요소2, ...};
    // 두번째 방법
    타입[] 배열이름 = new 타입[]{배열요소1, 배열요소2, ...};
    ```
    배열의 선언과 초기화를 따로 진행해야 하는 경우, 
   메소드의 인수로 배열을 전달하며 초기화해야하는 경우에는 두번째 방법만을 사용
   

2. 다차원 배열 :  2차원 이상의 배열을 의미하며, 배열 요소로 또 다른 배열을 가지는 배열을 의미  
   (1) 2차원 배열(two dimensional array) : 배열의 요소로 1차원 배열을 가지는 배열  
    * 문법  
    ```java
    타입[][] 배열이름;
    타입 배열이름[][];
    타입[] 배열이름[];
    ```
   
   (2) 배열의 선언과 동시에 초기화하는 방법
    * 문법
    ```java
    타입 배열이름[열의길이][행의길이] = {
    {배열요소[0][0], 배열요소[0][1], ...},
    {배열요소[1][0], 배열요소[1][1], ...},
    {배열요소[2][0], 배열요소[2][1], ...},
    ...
    };
    ```
   
   (3) 가변 배열(dynamic array) : 행마다 다른 길이의 배열을 저장할 수 있는 배열  
    
3. 배열의 활용  
   (1) 배열의 복사 : 자바에서 배열은 한 번 생성하면 그 길이를 변경할 수 없기 때문에,
        더 많은 데이터를 저장하기 위해서는 더욱 큰 배열을 만들고, 이전 배열의 데이터를 새로 만든 배열로 복사
    ```java
    int[] arr1 = new int[]{1, 2, 3, 4, 5};
    int newLen = 10;

    // 1. System 클래스의 arraycopy() 메소드
    int[] arr2 = new int[newLen];
    System.arraycopy(arr1, 0, arr2, 0, arr1.length);

    // 2. Arrays 클래스의 copyOf() 메소드
    int[] arr3 = Arrays.copyOf(arr1, 10);

    // 3. Object 클래스의 clone() 메소드
    int[] arr4 = (int[])arr1.clone();

    // 4. for 문과 인덱스를 이용한 복사
    int[] arr5 = new int[newLen];
    ```
   
    (2) Enhanced for문
     * 문법
    ```java
     for (타입 변수이름 : 배열이나컬렉션이름) {
    배열의 길이만큼 반복적으로 실행하고자 하는 명령문;
    }
    ```
   Enhanced for 문은 요소를 참조할 때만 사용하는 것이 좋으며, 요소의 값을 변경하는 작업에는 적합하지 않음.

## 클래스
1. 클래스의 개념
* 클래스 : 객체를 정의하는 틀 또는 설계도와 같은 의미
    * 클래스는 객체의 상태를 나타내는 필드(field)와 객체의 행동을 나타내는 메소드(method)로 구성
    
* 인스턴스 : 선언된 클래스에 할당된 객체

* 메소드 : 어떠한 특정 작업을 수행하기 위한 명령문의 집합  
  (클래스는 멤버(member)로 속성을 표현하는 필드(field)와 기능을 표현하는 메소드(method)를 가짐)
  ```java
  접근제어자 반환타입 메소드이름(매개변수목록) { // 선언부
    // 구현부
  }
  ```
  * 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시  
  * 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시
  * 메소드 이름 : 메소드를 호출하기 위한 이름을 명시  
  * 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시  
  * 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합
    
* 필드 : 클래스에 포함된 변수(variable)를 의미
  (필드는 선언된 위치에 따라 다음과 같이 구분)
  * 클래스 변수(static variable)
  * 인스턴스 변수(instance variable)  
  * 지역 변수(local variable)  
    
* 생성자 :  객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 메소드

2. 클래스의 선언
* 문법
    * 접근 제어자는 객체 지향 프로그래밍의 특징 중 하나인 정보 은닉(data hiding)을 위한 키워드
    * public 멤버는 모든 객체에서 접근할 수 있지만, private 멤버는 해당 객체 내의 멤버 변수나 메소드만이 접근할 수 있음
```java
접근제어자 class 클래스이름 {
    접근제어자 필드1의타입 필드1의이름;
    접근제어자 필드2의타입 필드2의이름;
    ...
    접근제어자 메소드1의 원형
    접근제어자 메소드2의 원형
    ...
};
``` 

* 인스턴스의 생성
    * 참조변수 선언 : `클래스이름 객체참조변수이름;`
    * 인스턴스 생성 : `객체참조변수이름 = new 클래스이름();`
    * 참조변수 선언 & 인스턴스 생성 : `클래스이름 객체참조변수이름 = new 클래스이름();`
    

## 메소드와 생성자
* 메소드 : 어떠한 특정 작업을 수행하기 위한 명령문의 집합
    * 중복되는 코드의 반복적인 프로그래밍을 피할 수 있음
    * 모듈화로 인해 코드의 가독성이 좋아짐
    * 프로그램에 문제가 발생하거나 기능의 변경이 필요할 때도 손쉽게 유지보수 가능
    * 메소드 호출
    ```java
    객체참조변수이름.메소드이름();                 // 매개변수가 없는 메소드의 호출
    객체참조변수이름.메소드이름(인수1, 인수2, ...); // 매개변수가 있는 메소드의 호출
    ```
  
* 생성자 : 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 메소드
    * 생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않음
    * 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있음
    * 객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있음
    ```java
    클래스이름() { ... }                  // 매개변수가 없는 생성자 선언
    클래스이름(인수1, 인수2, ...) { ... }  // 매개변수가 있는 생성자 선언
    ```        
    * 기본 생성자 : 매개변수를 하나도 가지지 않으며, 아무런 명령어도 포함하고 있지 않음  
      (특별히 생성자를 정의하지 않고도 인스턴스를 생성할 수 있도록 제공해주는 생성자)

* this와 this()
    * this 참조 변수 :  인스턴스가 바로 자기 자신을 참조하는 데 사용하는 변수
        * 인스턴스 메소드에서만 사용할 수 있으며, 클래스 메소드에서는 사용할 수 없음
    * this() 메소드 : 같은 클래스의 다른 생성자를 호출할 때 사용
        * 생성자 내부에서만 사용할 수 있음
        * this() 메소드에 인수를 전달하면, 생성자 중에서 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출
    
* 메소드 오버로딩
    * 메소드 시그니처(method signature) : 메소드의 선언부에 명시되는 매개변수의 리스트
    * 메소드 오버로딩(method overloading) : 같은 이름의 메소드를 중복하여 정의하는 것을 의미  
      (서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것)
    * 메소드 오버로딩의 조건
        * 메소드의 이름이 같아야 함
        * 메소드의 시그니처, 즉 매개변수의 개수 또는 타입이 달라야 함
    
* 재귀호출 : 메소드 내부에서 해당 메소드가 또다시 호출되는 것을 의미

## 제어자
* 패키지 : 클래스와 인터페이스의 집합
    * 선언 : `package 패키지이름;`
    * import 문 : 선언한 패키지에 속한 클래스를 다른 파일에서 사용하기 위해서 사용
        * 선언 : `import 패키지이름.클래스이름;`, `import 패키지이름.*;`
    
* 제어자 : 클래스와 클래스 멤버의 선언 시 사용하여 부가적인 의미를 부여하는 키워드
    * 접근 제어자 : 클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정하여 정보 은닉을 할 수 있는 제어자
        * private : 외부에 공개되지 않으며, 외부에서는 직접 접근할 수 없음
        * public : 외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 직접 접근
        * default : 같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근
        * protected : protected 멤버는 부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급
    * 기타 제어자
        * final : 오버라이딩(overriding)을 통한 재정의를 할 수 없음
        * static : 해당 변수를 클래스 변수로 만들어줌
        * abstract : 추상 메소드, 추상 클래스